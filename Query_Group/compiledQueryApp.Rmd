---
title: "Watershed Data Exploration Tool"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    social: menu
    source_code: embed
runtime: shiny
---
  
```{r global, include=FALSE}
# load necessary packages and data sets
library(shiny)
library(tidyverse)

wellNames = list('A5', 'A6', 'A7', 'D1', 'H4', 'I3', 'I6', 'I7', 'I8', 
                 'I9', 'JD01', 'JD02', 'JD03', 'JD04', 'JD05', 'JD06',
                 'JD07', 'JD08', 'JD10', 'JD11', 'JD12', 'JD13', 'JD14',
                 'JD15', 'JD16', 'JD17', 'JD18', 'JD19', 'JD20', 'JD21',
                 'JD22', 'JD23', 'JD24', 'JD25', 'JD26', 'JD27', 'JD28',
                 'JD29', 'JD30', 'JD31', 'K1', 'K10', 'K11', 'K12', 
                 'K1D', 'K4D', 'K4M', 'K4S', 'K5', 'K6D', 'K6S', 'K7D', 
                 'K7S', 'K8', 'K9', 'N1', 'N2', 'N3', 'N4', 'N5', 'O1', 
                 'O2', 'P1', 'P2', 'Q1', 'Q2', 'T1')

well_data <- read_csv("cleanAllWellData.csv")
slope_asp_data <- read_csv("slope_aspect_well_data.csv")
precip_data <- read_csv("PrecipSnow_BarData.csv")
hpu_data <- read_csv("hpuDataClean.csv")
discharge_data <- read_csv("CleanDischargeData_")
```

Column {.sidebar}
---------------------------------------------------------------------
  
Explore data from watershed 3 in Hubbard Brook.
  
```{r}
# determine min and max for slope data
minSlope <- min(slope_asp_data$Slope)
maxSlope <- max(slope_asp_data$Slope, na.rm = TRUE)

# make a slider widget for slope
sliderInput("slope", "Select a slope range", 
            min = minSlope, max = maxSlope,
            value = c(minSlope, maxSlope), ticks = TRUE, dragRange = TRUE)

# determine min and max for aspect data
minAsp <- min(slope_asp_data$Aspect)
maxAsp <- max(slope_asp_data$Aspect, na.rm = TRUE)

# make a slider widget for aspect
sliderInput("aspect", "Select an aspect range", 
            min = minAsp, max = maxAsp,
            value = c(minAsp, maxAsp), ticks = TRUE, dragRange = TRUE)

#checkbox group input that allows the user to select which HPU units they want to see
checkboxGroupInput("hpu", "Select desired HPU(s):", choices = unique(hpu_data$HPU), selected = unique(hpu_data$HPU))

# Select multiple wells based on well names
selectInput("select_wells", "Select Well(s):", 
            choices = wellNames, multiple = TRUE)

#check box that gives user option to select all the wells from the well list
checkboxInput("selectAllWellsBox", "Select all wells in well list", value = FALSE, width = NULL)

# Select a date range
dateRangeInput("date_range", "Select Date Range:", start = "2010-07-01", 
               end = "2018-01-10", format = "mm/dd/yy")

# plots/refreshes data
actionButton("plot_btn", label = "Plot")
```

Column
----------------------------------------------------------------------
---
title: "Row Orientation"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
---

### Precipitation

```{r}
# Updates the well input when plot button is clicked
final_datesP <- reactiveValues(x = NULL)

# Updates the date range input when plot button is clicked
observeEvent(input$plot_btn, {
  final_datesP$x <- c(input$date_range[1], input$date_range[2])
  })

# renders the plot
renderPlot({
  
  ggplot(data = precip_data, aes(fill = Type, y = Value, x = DATE)) + 
  geom_bar(position = "stack", stat = "identity") + ylab("Precipitation (mm)")+
    theme_classic() +
    coord_cartesian(xlim = as.Date(final_datesP$x, coord_cartesian), expand = FALSE)

})
```
  
Row
-------------------------------------
### Water Level Plot

```{r}
#changes wells in wells select input box if slope slider values change
observeEvent(input$slope, {updateSelectInput(session, input = "select_wells", label = NULL, choices = getWellList(input$slope[1], input$slope[2], input$aspect[1], input$aspect[2], input$hpu), selected = NULL)})

#changes wells in wells select input box if aspect slider values change
observeEvent(input$aspect, {updateSelectInput(session, input = "select_wells", label = NULL, choices = getWellList(input$slope[1], input$slope[2],input$aspect[1], input$aspect[2], input$hpu), selected = NULL)})

#changes wells in wells select input box if HPU selected box values change
observeEvent(input$hpu, {updateSelectInput(session, input = "select_wells", label = NULL, choices = getWellList(input$slope[1], input$slope[2],input$aspect[1], input$aspect[2], input$hpu))})


#provides functionality to check box that allows user to add all wells currently in the wells list to the graph
observeEvent(input$selectAllWellsBox, 
             {updateSelectInput(session, 
                                input = "select_wells", 
                                label = NULL, 
                                selected =if(input$selectAllWellsBox == TRUE){c(
                                  getWellList(input$slope[1], input$slope[2], input$aspect[1], input$aspect[2], input$hpu))
                                  }
                                )
               }
             )

# Updates the well input when plot button is clicked
wells <- eventReactive(input$plot_btn, {input$select_wells})

final_dates <- reactiveValues(x = NULL)

# Updates the date range input when plot button is clicked
observeEvent(input$plot_btn, {
  final_dates$x <- c(input$date_range[1], input$date_range[2])
  })

# Changes date range if brushing is detected
observeEvent(input$wl_dblclick, {
  brush <- input$wl_brush
  if (!is.null(brush))
    final_dates$x <- c(brush$xmin, brush$xmax)
  else
    final_dates$x <- c(input$date_range[1], input$date_range[2])
})

plotOutput("water_level", dblclick = "wl_dblclick", 
           brush = brushOpts(id = "wl_brush"))

# renders the plot
output$water_level <- renderPlot({
  
  # subsets the wells
  selected_well_data <- filter(well_data, Well == wells())
  
  ggplot(data = selected_well_data, mapping = aes(x = date, y = level, color = Well)) + 
    geom_line() + scale_y_reverse() + ylab("Water Table Depth (cm)") +
    xlab("Date") + theme_classic() +
    coord_cartesian(xlim = as.POSIXct(final_dates$x, origin = "1970-01-01"), expand = FALSE)
})
```

Row
-------------------------------------
### Discharge
```{r}
renderPlot({
  ggplot(discharge_data, mapping = aes(x = Date, y = Discharge_ls))+
  geom_line()+ 
  theme_classic() +
  ylab("Discharge Liter/Second")+
  xlab("Date")
})

```

```{r}
#helper function for the narrowing down well names by slope and aspect. Takes the min and max vals and uses slope_asp_data to get the updated well names.
getWellList <- function(minValSlope, maxValSlope, minValAsp, maxValAsp, hpuValsList) { 
    #makes list of wells that fit slope and aspect selected by the sliders
    saWells <- slope_asp_data %>% 
      filter(between(Slope,minValSlope, maxValSlope), 
             between(Aspect, minValAsp, maxValAsp)) %>% 
      select(Well)
    
    #makes list of wells that fit HPU selected by user 
    hpuWells <- hpu_data %>% 
      subset(HPU %in% hpuValsList) %>% 
      select(Well)
    
    #makes list of wells that are in both the slope/aspect list and the HPU list
    combWells <- intersect(hpuWells, saWells)
    
    #returns filtered wells list
    return(t(combWells))
  }
```